//! External API types for communication between Frontend and Backend
//!
//! These types define the public REST API contract that external clients
//! (like the frontend) use to communicate with our backend service.

use crate::error::{Result, ValidationError};
use serde::{Deserialize, Serialize};

/// Request to ingest a GitHub repository
///
/// The frontend sends this to initiate the ingestion process for a new project.
/// The GitHub URL will be validated and canonicalized by the backend.
#[derive(Deserialize, Serialize)]
pub struct IngestRequest {
    /// The GitHub repository URL to ingest (any valid format accepted)
    ///
    /// Examples:
    /// - `https://github.com/owner/repo`
    /// - `https://github.com/Owner/Repo.git`
    /// - `https://github.com/owner/repo/`
    pub github_url: url::Url,
}

/// Response from successful repository ingestion
///
/// Contains the canonicalized GitHub URL that should be used in subsequent
/// API calls to ensure consistency.
#[derive(Serialize, Deserialize)]
pub struct IngestResponse {
    /// The canonicalized GitHub repository URL
    ///
    /// Always in the format: `https://github.com/owner/repo.git`
    /// - Lowercase owner and repository names
    /// - Always includes `.git` suffix
    /// - No trailing slashes or extra path segments
    pub canonical_github_url: url::Url,
}

/// Request to ask a question about an ingested project
///
/// The frontend sends this to get AI-powered answers about a specific
/// repository that has been previously ingested.
#[derive(Deserialize)]
#[cfg_attr(test, derive(Debug))]
pub struct AnswerRequest {
    /// The canonical GitHub repository URL (from IngestResponse)
    ///
    /// Must exactly match the `canonical_url` returned from the ingest endpoint.
    /// If the URL doesn't match any ingested project, a 404 error will be returned.
    pub canonical_github_url: url::Url,

    /// The question to ask about the repository
    ///
    /// Can be any natural language question about the codebase, documentation,
    /// architecture, implementation details, etc.
    pub question: String,
}

impl AnswerRequest {
    /// Maximum allowed length for a question (in characters)
    const MAX_QUESTION_LENGTH: usize = 2000;

    /// Create a new AnswerRequest with comprehensive validation.
    ///
    /// Validates:
    /// - Trims whitespace
    /// - Rejects empty questions
    /// - Enforces length limits
    /// - Checks for invalid control characters
    pub fn new(canonical_github_url: url::Url, question: String) -> Result<Self> {
        let trimmed = question.trim();

        // Check for empty input
        if trimmed.is_empty() {
            return Err(ValidationError::EmptyInput(
                "Question cannot be empty".to_string(),
            ))?;
        }

        // Check length limit
        if trimmed.len() > Self::MAX_QUESTION_LENGTH {
            return Err(ValidationError::InputTooLong(format!(
                "Question must be {} characters or less, got {}",
                Self::MAX_QUESTION_LENGTH,
                trimmed.len()
            )))?;
        }

        // Check for control characters (except newlines and tabs which are OK for questions)
        if trimmed
            .chars()
            .any(|c| c.is_control() && c != '\n' && c != '\t')
        {
            return Err(ValidationError::InvalidCharacters(
                "Question contains invalid control characters".to_string(),
            ))?;
        }

        Ok(AnswerRequest {
            canonical_github_url,
            question: trimmed.to_string(),
        })
    }
}

/// Response containing the AI-generated answer
///
/// Provides both the answer and confirmation of which project was queried.
#[derive(Serialize)]
pub struct AnswerResponse {
    /// The AI-generated answer to the user's question
    ///
    /// This response is generated by the LLM using the ingested codebase
    /// as context along with the user's question.
    pub answer: String,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::error::{Error, ValidationError};
    use rstest::rstest;
    use url::Url;

    fn test_url() -> Url {
        Url::parse("https://github.com/owner/repo.git").unwrap()
    }

    #[rstest]
    #[case("Valid question")]
    #[case("What is this repository about?")]
    #[case("How does the authentication work?\nCan you explain?")]
    #[case("Question with\ttabs")]
    #[case(&"a".repeat(2000))] // Exactly at limit
    #[case("  Valid question with spaces  ")]
    #[case("\n\tQuestion with whitespace\n\t")]
    #[case("   Multiple   spaces   inside   ")]
    fn test_valid_questions(#[case] question: &str) {
        let result = AnswerRequest::new(test_url(), question.to_string());

        let request = result.unwrap();
        assert_eq!(request.question, question.trim());
        assert_eq!(request.canonical_github_url, test_url());
    }

    #[rstest]
    #[case("")]
    #[case("   ")]
    #[case("\n\t  \n")]
    fn test_empty_input_validation(#[case] question: &str) {
        let result = AnswerRequest::new(test_url(), question.to_string());

        assert!(matches!(
            result.unwrap_err(),
            Error::ValidationError(ValidationError::EmptyInput(_))
        ));
    }

    #[rstest]
    #[case(&"a".repeat(2001))] // Just over limit
    #[case(&"a".repeat(5000))] // Way over limit
    fn test_length_validation(#[case] question: &str) {
        let result = AnswerRequest::new(test_url(), question.to_string());

        assert!(matches!(
            result.unwrap_err(),
            Error::ValidationError(ValidationError::InputTooLong(_))
        ));
    }

    #[rstest]
    #[case("Question with \x00 null byte")]
    #[case("Question with \x01 control char")]
    #[case("Question with \x1F control char")]
    #[case("Question with \x7F delete char")]
    fn test_control_character_validation(#[case] question: &str) {
        let result = AnswerRequest::new(test_url(), question.to_string());

        assert!(matches!(
            result.unwrap_err(),
            Error::ValidationError(ValidationError::InvalidCharacters(_))
        ));
    }
}
